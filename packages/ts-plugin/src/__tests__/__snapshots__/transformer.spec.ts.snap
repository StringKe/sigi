// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ts-plugin specs should transform alias 1`] = `

File: alias.tsx
TypeScript before transform:
  import { EffectModule, Module } from '@sigi/core'
  import { SSREffect as _Effect } from '@sigi/ssr'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @_Effect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello')
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module } from '@sigi/core';
  import { SSREffect as _Effect } from '@sigi/ssr';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @_Effect({})
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
  }
  

`;

exports[`ts-plugin specs should transform do-nothing 1`] = `

File: do-nothing.tsx
TypeScript before transform:
  import { EffectModule, Module } from '@sigi/core'
  import { SSREffect } from 'not-sigi'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello')
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  
    normalMethod() {
  
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module } from '@sigi/core';
  import { SSREffect } from 'not-sigi';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello');
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
    normalMethod() {
    }
  }
  

`;

exports[`ts-plugin specs should transform named-import 1`] = `

File: named-import.tsx
TypeScript before transform:
  import { EffectModule, Module } from '@sigi/core'
  import { SSREffect } from '@sigi/ssr'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({
      skipFirstClientDispatch: true,
      payloadGetter: (req: Request) => {
        return require('md5')('hello')
      },
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module } from '@sigi/core';
  import { SSREffect } from '@sigi/ssr';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({})
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
  }
  

`;

exports[`ts-plugin specs should transform namespace-import 1`] = `

File: namespace-import.tsx
TypeScript before transform:
  import { EffectModule, Module } from '@sigi/core'
  import * as SSR from '@sigi/ssr'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSR.SSREffect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello')
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module } from '@sigi/core';
  import * as SSR from '@sigi/ssr';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSR.SSREffect({})
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
  }
  

`;

exports[`ts-plugin specs should transform no-argument 1`] = `

File: no-argument.tsx
TypeScript before transform:
  import { EffectModule, Module, Reducer } from '@sigi/core'
  import { SSREffect } from '@sigi/ssr'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect()
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  
    @Reducer()
    reducer(state: AState) {
      return { ...state }
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module, Reducer } from '@sigi/core';
  import { SSREffect } from '@sigi/ssr';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect()
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
    @Reducer()
    reducer(state: AState) {
      return { ...state };
    }
  }
  

`;

exports[`ts-plugin specs should transform without-named-binding 1`] = `

File: without-named-binding.tsx
TypeScript before transform:
  import { EffectModule, Module } from '@sigi/core'
  import '@sigi/ssr'
  import { Request } from 'express'
  import { Observable } from 'rxjs'
  import { map } from 'rxjs/operators'
  
  interface AState {}
  
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello')
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(
        map(() => this.createNoopAction())
      )
    }
  }
  
      ↓ ↓ ↓ ↓ ↓ ↓
TypeScript after transform:
  import { EffectModule, Module } from '@sigi/core';
  import '@sigi/ssr';
  import { Request } from 'express';
  import { Observable } from 'rxjs';
  import { map } from 'rxjs/operators';
  interface AState {
  }
  @Module('A')
  export class ModuleA extends EffectModule<AState> {
    @SSREffect({
      payloadGetter: (req: Request) => {
        return require('md5')('hello');
      }
    })
    whatever(payload$: Observable<string>) {
      return payload$.pipe(map(() => this.createNoopAction()));
    }
  }
  

`;
